import subprocess
from sys import argv
import os
from collections import namedtuple, deque
from librosa.core import note_to_midi
from time import sleep

def generate_pdf(file_name):
	file_name = "".join(file_name.strip())
	if os.path.isfile('../bin/mscx_files/{0}.mscx'.format(file_name)):
		subprocess.run("MuseScore3 ../bin/mscx_files/{0}.mscx -o {0}.pdf".format(file_name))
		sleep(1)
		os.startfile("{0}.pdf".format(file_name))
	else:
		print('Please make sure that you inputted a valid .mscx file name, and have it located in the /bin/mscx_files/ directory.')
		raise FileNotFoundError('Program was unable to find file {0}.mscx in the /bin/mscx_files/ directory.'.format(file_name))


def generate_ly_pdf(file_name):
	"""
	Input: A file_name with no file type suffix
	Output: A PDF which is opened in a new window
	"""
	if os.path.isfile('../bin/ly_files/{0}.ly'.format(file_name)):
		subprocess.run("lilypond --pdf ../bin/ly_files/{0}.ly".format(file_name))
		os.startfile("{0}.pdf".format(file_name))
	else:
		print('Please make sure that you inputted a valid .ly file name, and moved it into the /bin/ly_files/ directory.')
		raise FileNotFoundError('Program was unable to find file {0}.ly in the /bin/ly_files/ directory.'.format(file_name))

def write_mscx_file(file_name, note_list):
	file_name = "".join(file_name.strip())
	tpc_vals = {"F":13, "C":14, "G" : 15, "D" : 16, "A": 17, "E" : 18, "B" : 19, "F#":20, "C#":21, "G#":22, "D#":23, "A#":24, "E#":25, "B#":26}

	f = open('../bin/mscx_files/{0}.mscx'.format(file_name), "w+", encoding="utf-8")
	f_template = open('../bin/mscx_files/file_template.mscx', 'r', encoding="utf-8")
	for line in f_template:
		f.write(line)

	f_template.close()

	measure_template = "\n<Measure><voice>{0}</voice></Measure>\n"
	note_template = "\n<Chord><durationType>quarter</durationType><Note><pitch>{3}</pitch><tpc>{4}</tpc><Fingering><text>{2}</text></Fingering><fret>{1}</fret><string>{0}</string></Note></Chord>\n"
	closing_line = "</Staff>\n\t</Score>\n</museScore>\n\n"

	note_path = list(generate_finger_options(note_list))
	note_path = note_path[1:-1]

	measure_str = ""
	note_str = ""
	curr_measure = measure_template
	curr_note = note_template
	for i, note in enumerate(note_path):

		curr_note = curr_note.format(note.string, note.fret, note.finger, note_to_midi(note.pitch), tpc_vals[note.pitch[:-1]])
		note_str = note_str + curr_note
		curr_note = note_template

		if (i+1) % 4 == 0: 
			curr_measure = curr_measure.format(note_str)
			note_str = ""
			measure_str = measure_str + curr_measure
			curr_measure = measure_template


	if len(note_str) != 0:
		curr_measure = curr_measure.format(note_str)
		note_str = ""
		measure_str = measure_str + curr_measure
		curr_measure = measure_template

	f.write(measure_str)
	f.write(closing_line)



def write_ly_file(file_name, note_list, song_name=None, generate_explicit_staff=True):
	"""
	Input: This method takes in a file_name, a list of notes (as strings), and optionally takes a song name.
	Output: It writes a file, called {file_name}.ly without brackets, and uses the song name to properly
	add title/header information to the pdf that would be outputted by running the .ly file
	through lilypond. It then uses explicit pitch representation in lilypond to properly write the tablature.

	TO-DO: Implement an algorithm to determine the fingering of tablature, and 
	"""
	if song_name == None:
		song_name = file_name

	# Begin writing .ly file with the lilypond version and title information
	f = open('../bin/ly_files/{0}.ly'.format(file_name), "w+", encoding="utf-8")
	f.write('\\version \"2.16.0\" % necessary for upgrading to future LilyPond versions.\n\n')
	header_str = '\\header{\n'
	title_str = '\ttitle = \"Tablature for the song {0}\"\n'.format(song_name)
	subtitle_str = '\tsubtitle = \". . . as generated by GuiTabs\"\n'
	f.write(header_str + title_str + subtitle_str + '}\n\n\n\n')

	# Note that for the notes, we have that a, b, c, d, e, f, g are the notes below C4 (middle c)
	# Use , to decrease by an octave, ' to increase by an octave
	# Sharps are represented by adding "is" to the name, while flats use "es"
	# As a general assumption, we're guessing that we shouldn't have weird notes like C11 (e.g. ridiculously high notes)
	# Note that from our pitch tracker, we only have sharp notes and regular notes. Therefore we will never use "es"
	note_wrapper_tab = '\\new TabStaff {\n'

	if generate_explicit_staff:
		note_wrapper_explicit = '\\new Staff {\n'

	end_wrapper = ' \\bar "|."\n}\n\n'
	note_lines = '\t'
	for note in note_list:
		note = note.lower()
		pitch_class = note[0]
		is_sharp = ''
		octave_number = None
		if len(note) == 3:
			# Has a sharp
			is_sharp = 'is'
			octave_number = int(note[2])
		elif len(note) == 2:
			octave_number = int(note[1])
		else:
			# We have an issue, note is not of the form that we allow
			raise InvalidNoteError('We have encountered an invalid note: {0}'.format(note))

		# Check length of the note lines just to make sure it's readable if you want to look
		# directly at the .ly file

		explicit_pitch_note = pitch_class + is_sharp
		if octave_number < 3:
			# Add one or two , based on octave number
			octave_diff = 3-octave_number
			for i in range(octave_diff):
				explicit_pitch_note = explicit_pitch_note + ','
		elif octave_number > 3:
			octave_diff = octave_number-3
			for i in range(octave_diff):
				explicit_pitch_note = explicit_pitch_note + '\''

		note_lines = note_lines + explicit_pitch_note +' '
		if len(note_lines) >= 12:
			note_wrapper_tab = note_wrapper_tab + note_lines + '\n'
			if generate_explicit_staff:
				note_wrapper_explicit = note_wrapper_explicit + note_lines + '\n'

			note_lines = '\t'

	if generate_explicit_staff:
		f.write(note_wrapper_explicit + note_lines + end_wrapper)

	f.write(note_wrapper_tab + note_lines + end_wrapper)

"""
Setting up weighted Graph class and Edge namedtuples for running Dijkstra's
"""

inf = float('inf')
Edge = namedtuple('Edge', 'parent, child, distance')
Note = namedtuple('Note', 'pitch, string, fret, position, finger, occcurrence')
# Note has the following attributes: pitch, string, fret, position, finger
# Pitch refers to the explicit note pitch, e.g. A#4
# String refers to the string number the note is played on, 1 through 6
# Fret refers to the fret the note will be played on
# Position refers to the hand position at time of playing (unless it's an open note, this must be within the range of fret and fret - 6)
# Finger refers to the finger that should be playing the note (1 through 4, index, middle, ring, and pinky)
def distance(note1, note2):
	# If it's a starting or ending pair, there is no distance between the two
	if note1.pitch == "START" or note2.pitch == "END":
		return 0

	dist = 0

	# If the next note is an open string, just give it a small weight and penalize shifting your hands much less
	if note2.fret == 0:
		return 1 + abs(note2.position - note1.position)**4

	# If the same fret is being played on the same string, just switching off fingers, penalize it less
	if note1.fret == note2.fret and note1.string == note2.string:
		return abs(note2.finger - note1.finger) + 1

	if note2.finger == 2 and note2.fret - note2.position == 0:
		dist += 10**2

	if note1.position == note2.position and note1.fret == note2.fret and note1.string != note2.string:
		if note1.string < note2.string and note2.finger > note1.finger:
			return inf

	if note1.position != note2.position and note1.finger == note2.finger:
		fret_string_dist = (note2.fret - note1.fret)**3 + (note2.string - note1.string)**4
		dist += (5*(note2.position - note1.position))**2 +  fret_string_dist


	# Stretching more than 4 frets is pretty much impossible unless you have some legitimately ridiculous hands or are playing VERY high up on the fretboard
	# If you're high up on the fretboard, stretching more than 6 is pretty much unneccessary
	if note1.position == note2.position and not note1.fret == 0:
		stretch_amt = abs(note2.fret - note1.fret) 
		if note1.position >= 10:
			if stretch_amt > 6:
				return inf

		else:
			if stretch_amt > 4 :
				return inf

		dist += 2*stretch_amt + abs(note2.string - note1.string)

	if note1.finger != note2.finger and note2.finger > note1.finger:
		finger_diff = note2.finger - note1.finger
		fret_diff = note2.fret - note1.fret

		dist += ((5*fret_diff)**3)/(4*finger_diff**2)

	if note1.finger == note2.finger and not note1.fret == 0 and not note2.fret == 0:
		dist += (5 * abs(note1.string - note2.string))**3

	# Heavily penalize the need to shift relative position of hand (e.g. moving hand from bottom of fretboard to top of fretboard)
	# Penalize shifting from high up to lower slightly less
	if note1.position != note2.position:
		if note2.position > note1.position:
			dist += (3 * (note2.position - note1.position))**4
		else:
			dist += (2 * (note2.position - note1.position))**2

	dist += note1.position**4
	dist += note2.position**6

	return dist



def make_edge(parent, child):
	"""
	Input: Start and end point of an edge
	Output: An edge as represented by the namedtuple containing its parent node, child node, and distance between the two 
	"""
	return Edge(parent, child, distance(parent, child))

class Graph:
	def __init__(self, vertices, edges):
		self.edges = [make_edge(*edge) for edge in edges]
		self.vertices = vertices

	@property
	def neighbors(self):
		neighbors = {vertex: set() for vertex in self.vertices}
		for edge in self.edges:
			neighbors[edge.parent].add((edge.child, edge.distance))

		return neighbors

	def dijkstra(self, source, destination):
		"""
		Input: A source and destination vertex
		Output: The shortest path between source and destination in the weighted graph calling this function
		"""
		distances = {vertex: inf for vertex in self.vertices}
		prev = {vertex: None for vertex in self.vertices}

		distances[source] = 0
		vertices = self.vertices.copy()

		while len(vertices) != 0:
			curr = min(vertices, key=lambda v: distances[v])
			vertices.remove(curr)

			if distances[curr] == inf:
				break

			for neighbor, dist in self.neighbors[curr]:
				route = distances[curr] + dist
				if route < distances[neighbor]:
					distances[neighbor] = route
					prev[neighbor] = curr

		shortest_path, curr = deque(), destination

		while prev[curr] is not None:
			shortest_path.appendleft(curr)
			curr = prev[curr]

		if shortest_path:
			shortest_path.appendleft(curr)

		return shortest_path
	
def generate_finger_options(note_series):
	notes_on_string = [
	["E4", "F4", "F#4", "G4", "G#4", "A4", "A#4", "B4", "C5", "C#5", "D5", "D#5", "E5", "F5", "F#5", "G5", "G#5", "A5", "A#5", "B5", "C6", "C#6", "D6" ],
	["B3", "C4", "C#4", "D4", "D#4", "E4", "F4", "F#4", "G4", "G#4", "A4", "A#4", "B4", "C5", "C#5", "D5", "D#5", "E5", "F5", "F#5", "G5", "G#5", "A5" ],
	["G3", "G#3", "A3", "A#3", "B3", "C4", "C#4", "D4", "D#4", "E4", "F4", "F#4", "G4", "G#4", "A4", "A#4", "B4", "C5", "C#5", "D5", "D#5", "E5", "F5" ],
	["D3", "D#3", "E3", "F3", "F#3", "G3", "G#3", "A3", "A#3", "B3", "C4", "C#4", "D4", "D#4", "E4", "F4", "F#4", "G4", "G#4", "A4", "A#4", "B4", "C5" ],
	["A2", "A#2", "B2", "C3", "C#3", "D3", "D#3", "E3", "F3", "F#3", "G3", "G#3", "A3", "A#3", "B3", "C4", "C#4", "D4", "D#4", "E4", "F4", "F#4", "G4" ],
	["E2", "F2", "F#2", "G2", "G#2", "A2", "A#2", "B2", "C3", "C#3", "D3", "D#3", "E3", "F3", "F#3", "G3", "G#3", "A3", "A#3", "B3", "C4", "C#4", "D4" ]
	]
	# Fret numbers for reference
	# 0     1     2      3     4      5     6      7     8     9      10 	11	   12    13     14     15    16    17    18     19    20     21    22

	# Index n refers to string n+1 in the above "notes_on_string" list
	# For the above picture, see the following image:
	# https://www.researchgate.net/figure/Notes-on-a-guitar-fretboard_fig1_255587183	
	
	# Turn note_series into "layers" of vertices
	# Each layer contains all the possible note_tuples for a given note (e.g. (note, string number, fret number, hand position, finger on fret))
	# Given notes are tuples such as note_tuple = (note, string number, fret number, hand position, finger on fret)
	# edges are simply 2-tuples, (note_tuple1, note_tuple2)
	
	vertex_layers = []
	start_note = Note("START", None, None, None, None, None)
	vertex_layers.append([start_note])
	
	# Note = namedtuple('Note', 'pitch, string, fret, position, finger')
	occurrence = 0
	for note in note_series:
		note_vertices = []
		for i, string in enumerate(notes_on_string):
			if note in string:
				fret = string.index(note)
				if fret == 0:
					for position in range(1, 17):
						note_vertices.append(Note(note, i, fret, position, 0, occurrence))
				else:
					fret_index = fret - 4
					if fret_index <= 0:
						fret_index = 1
					for position in range(fret_index, fret+1):
						stretch_distance = fret - position
						if stretch_distance >= 3:
							note_vertices.append(Note(note, i, fret, position, 4, occurrence))

						if stretch_distance == 0:
							note_vertices.append(Note(note, i, fret, position, 1, occurrence))
							note_vertices.append(Note(note, i, fret, position, 2, occurrence))

						if stretch_distance == 1:
							note_vertices.append(Note(note, i, fret, position, 2, occurrence))

						if stretch_distance == 2:
							note_vertices.append(Note(note, i, fret, position, 3, occurrence))
		occurrence += 1

		vertex_layers.append(note_vertices)

	end_note = Note("END", None, None, None, None, None)
	vertex_layers.append([end_note])
	# For the first layer, generate a special "start_note" tuple with 0 edge weight to give a source for our graph search
	# For the final layer, generate a special "end_note" tuple with 0 edge weight to give a destination for our graph search
	# after generating the "layers" of vertices, generate the edges between each two layers
	# For a layer l_i s.t. |l_i| = m, and l_{i+1} s.t. |l_{i+1}| = n, we will have mn edges
	
	# Finally, generate our graph with the total set of vertices and edges, and run dijkstra's between our start_note and end_note
	# Then just parse the returned vertex path to get the optimal fingering for our note series
	vertices = []
	edges = []
	for index in range(len(vertex_layers) - 1):
		print('Configuring layer: {0} -> {1}'.format(index, index+1))
		for parent in vertex_layers[index]:
			vertices.append(parent)
			for child in vertex_layers[index+1]:
				edges.append((parent, child))

	vertices.append(end_note)

	graph = Graph(vertices, edges)
	shortest_path = graph.dijkstra(start_note, end_note)
	
	return shortest_path
	

if __name__ == "__main__":
	# example_notes = ['C4', 'E5', 'E4', 'D4', 'D#4', 'E4']
	# example_notes = ['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4']
	example_notes = ['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4', 'C4', 'D4', 'E4', 'F4', 'G4', 'A4',  'B4', 'C4',  'C4', 'D3', 'B4', 'A4', 'A4', 'G4', 'F4', 'E4', 'E4', 'E4', 'D4', 'C4', 'B3', 'A3', 'A3', 'G3', 'F3', 'E3', 'D3', 'D4', 'C3']
	shortest_path = generate_finger_options(example_notes)
	for x in shortest_path:
		print(x)

	write_mscx_file('Example1', example_notes)
	generate_pdf('Example1')
	# write_ly_file('Example1', example_notes)
	# generate_pdf('Example1')
